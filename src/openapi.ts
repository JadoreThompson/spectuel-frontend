/**
 * Generated by orval v8.1.0 ðŸº
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import { customFetch } from './lib/custom-fetch'
export interface AssetBalanceItem {
    symbol: string
    quantity: number
}

export type BalanceEventReadPayload = { [key: string]: unknown }

export interface BalanceEventRead {
    event_id: string
    user_id: string
    command_id: string
    type: string
    version: number
    symbol: string | null
    payload: BalanceEventReadPayload
    timestamp: number
}

export interface BarData {
    symbol: string
    timeframe: string
    timestamp: number
    open: number
    high: number
    low: number
    close: number
}

export interface BarsResponse {
    bars: BarData[]
    next_page_token?: string | null
}

export interface ContactForm {
    name: string
    email: string
    message: string
}

export interface ValidationError {
    loc: (string | number)[]
    msg: string
    type: string
}

export interface HTTPValidationError {
    detail?: ValidationError[]
}

export type StrategyType = (typeof StrategyType)[keyof typeof StrategyType]

export const StrategyType = {
    single: 'single',
    oco: 'oco',
    oto: 'oto',
    otoco: 'otoco',
} as const

export type OrderType = (typeof OrderType)[keyof typeof OrderType]

export const OrderType = {
    market: 'market',
    limit: 'limit',
    stop: 'stop',
} as const

export type Side = (typeof Side)[keyof typeof Side]

export const Side = {
    bid: 'bid',
    ask: 'ask',
} as const

export interface OrderBase {
    order_type: OrderType
    side: Side
    quantity: number
    limit_price?: number | null
    stop_price?: number | null
}

export interface OCOOrderCreate {
    strategy_type: StrategyType
    symbol: string
    /**
     * @minItems 2
     * @maxItems 2
     */
    legs: OrderBase[]
}

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]

export const OrderStatus = {
    pending: 'pending',
    placed: 'placed',
    partially_filled: 'partially_filled',
    filled: 'filled',
    cancelled: 'cancelled',
} as const

export interface OrderRead {
    order_type: OrderType
    side: Side
    quantity: number
    limit_price?: number | null
    stop_price?: number | null
    order_id: string
    symbol: string
    strategy_type: StrategyType
    status: OrderStatus
    executed_quantity: number
    avg_fill_price?: number | null
    created_at: string
}

export interface OCOOrderResponse {
    group_id: string
    legs: OrderRead[]
}

export interface OTOCOOrderCreate {
    strategy_type: StrategyType
    symbol: string
    parent: OrderBase
    /**
     * @minItems 2
     * @maxItems 2
     */
    oco_legs: OrderBase[]
}

export interface OTOCOOrderResponse {
    group_id: string
    parent: OrderRead
    legs: OrderRead[]
}

export interface OTOOrderCreate {
    strategy_type: StrategyType
    symbol: string
    parent: OrderBase
    child: OrderBase
}

export interface OTOOrderResponse {
    parent: OrderRead
    child: OrderRead
}

export type OrderEventReadPayload = { [key: string]: unknown }

export interface OrderEventRead {
    event_id: string
    order_id: string
    user_id: string
    command_id: string
    type: string
    version: number
    symbol: string
    payload: OrderEventReadPayload
    timestamp: number
}

export interface OrderModify {
    limit_price?: number | null
    stop_price?: number | null
}

export interface PaginatedResponseBalanceEventRead {
    page: number
    size: number
    has_next: boolean
    data: BalanceEventRead[]
}

export interface PaginatedResponseOrderEventRead {
    page: number
    size: number
    has_next: boolean
    data: OrderEventRead[]
}

export interface PaginatedResponseOrderRead {
    page: number
    size: number
    has_next: boolean
    data: OrderRead[]
}

export interface SingleOrderCreate {
    order_type: OrderType
    side: Side
    quantity: number
    limit_price?: number | null
    stop_price?: number | null
    strategy_type: StrategyType
    symbol: string
}

export interface SingleOrderResponse {
    order: OrderRead
}

export type TimeFrame = (typeof TimeFrame)[keyof typeof TimeFrame]

export const TimeFrame = {
    '1m': '1m',
    '5m': '5m',
    '15m': '15m',
    '1h': '1h',
    '4h': '4h',
    '1d': '1d',
} as const

export interface UpdateEmail {
    email: string
}

export interface UpdatePassword {
    password: string
}

export interface UpdateUsername {
    username: string
}

export interface UserCreate {
    password: string
    username: string
    email: string
}

export interface UserLogin {
    username?: string | null
    email?: string | null
    password: string
}

export interface UserMe {
    username: string
}

export type VerifyActionAction =
    (typeof VerifyActionAction)[keyof typeof VerifyActionAction]

export const VerifyActionAction = {
    change_username: 'change_username',
    change_password: 'change_password',
    change_email: 'change_email',
} as const

export interface VerifyAction {
    code: string
    action: VerifyActionAction
}

export interface VerifyCode {
    code: string
}

export interface WsTokenResponse {
    token: string
}

export type GetOrdersOrdersGetParams = {
    /**
     * @minimum 1
     */
    page?: number
    symbols?: string[]
    status?: OrderStatus[]
    side?: Side[]
    order?: GetOrdersOrdersGetOrder
}

export type GetOrdersOrdersGetOrder =
    (typeof GetOrdersOrdersGetOrder)[keyof typeof GetOrdersOrdersGetOrder]

export const GetOrdersOrdersGetOrder = {
    asc: 'asc',
    desc: 'desc',
} as const

export type GetUserEventsUserEventsGetParams = {
    type: GetUserEventsUserEventsGetType
    symbol?: string | null
    /**
     * @minimum 0
     */
    skip?: number
    /**
     * @minimum 1
     * @maximum 100
     */
    limit?: number
}

export type GetUserEventsUserEventsGetType =
    (typeof GetUserEventsUserEventsGetType)[keyof typeof GetUserEventsUserEventsGetType]

export const GetUserEventsUserEventsGetType = {
    balance: 'balance',
    order: 'order',
} as const

export type GetAssetBalancesUserAssetBalancesGetParams = {
    /**
     * Comma-separated list of symbols (e.g., BTCUSD,ETHUSD)
     */
    symbols?: string | null
}

export type GetMarketBarsMarketsSymbolBarsGetParams = {
    timeframe: TimeFrame
    start_date?: number | null
    end_date?: number | null
    next_page_token?: string | null
}

/**
 * @summary Login
 */
export type loginAuthLoginPostResponse200 = {
    data: unknown
    status: 200
}

export type loginAuthLoginPostResponse422 = {
    data: HTTPValidationError
    status: 422
}

export type loginAuthLoginPostResponseSuccess =
    loginAuthLoginPostResponse200 & {
        headers: Headers
    }
export type loginAuthLoginPostResponseError = loginAuthLoginPostResponse422 & {
    headers: Headers
}

export type loginAuthLoginPostResponse =
    | loginAuthLoginPostResponseSuccess
    | loginAuthLoginPostResponseError

export const getLoginAuthLoginPostUrl = () => {
    return `/auth/login`
}

export const loginAuthLoginPost = async (
    userLogin: UserLogin,
    options?: RequestInit
): Promise<loginAuthLoginPostResponse> => {
    return customFetch<loginAuthLoginPostResponse>(getLoginAuthLoginPostUrl(), {
        ...options,
        method: 'POST',
        headers: { 'Content-Type': 'application/json', ...options?.headers },
        body: JSON.stringify(userLogin),
    })
}

/**
 * @summary Register
 */
export type registerAuthRegisterPostResponse200 = {
    data: unknown
    status: 200
}

export type registerAuthRegisterPostResponse422 = {
    data: HTTPValidationError
    status: 422
}

export type registerAuthRegisterPostResponseSuccess =
    registerAuthRegisterPostResponse200 & {
        headers: Headers
    }
export type registerAuthRegisterPostResponseError =
    registerAuthRegisterPostResponse422 & {
        headers: Headers
    }

export type registerAuthRegisterPostResponse =
    | registerAuthRegisterPostResponseSuccess
    | registerAuthRegisterPostResponseError

export const getRegisterAuthRegisterPostUrl = () => {
    return `/auth/register`
}

export const registerAuthRegisterPost = async (
    userCreate: UserCreate,
    options?: RequestInit
): Promise<registerAuthRegisterPostResponse> => {
    return customFetch<registerAuthRegisterPostResponse>(
        getRegisterAuthRegisterPostUrl(),
        {
            ...options,
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
            },
            body: JSON.stringify(userCreate),
        }
    )
}

/**
 * @summary Request Email Verification
 */
export type requestEmailVerificationAuthRequestEmailVerificationPostResponse200 =
    {
        data: unknown
        status: 200
    }

export type requestEmailVerificationAuthRequestEmailVerificationPostResponseSuccess =
    requestEmailVerificationAuthRequestEmailVerificationPostResponse200 & {
        headers: Headers
    }
export type requestEmailVerificationAuthRequestEmailVerificationPostResponse =
    requestEmailVerificationAuthRequestEmailVerificationPostResponseSuccess

export const getRequestEmailVerificationAuthRequestEmailVerificationPostUrl =
    () => {
        return `/auth/request-email-verification`
    }

export const requestEmailVerificationAuthRequestEmailVerificationPost = async (
    options?: RequestInit
): Promise<requestEmailVerificationAuthRequestEmailVerificationPostResponse> => {
    return customFetch<requestEmailVerificationAuthRequestEmailVerificationPostResponse>(
        getRequestEmailVerificationAuthRequestEmailVerificationPostUrl(),
        {
            ...options,
            method: 'POST',
        }
    )
}

/**
 * @summary Verify Email
 */
export type verifyEmailAuthVerifyEmailPostResponse200 = {
    data: unknown
    status: 200
}

export type verifyEmailAuthVerifyEmailPostResponse422 = {
    data: HTTPValidationError
    status: 422
}

export type verifyEmailAuthVerifyEmailPostResponseSuccess =
    verifyEmailAuthVerifyEmailPostResponse200 & {
        headers: Headers
    }
export type verifyEmailAuthVerifyEmailPostResponseError =
    verifyEmailAuthVerifyEmailPostResponse422 & {
        headers: Headers
    }

export type verifyEmailAuthVerifyEmailPostResponse =
    | verifyEmailAuthVerifyEmailPostResponseSuccess
    | verifyEmailAuthVerifyEmailPostResponseError

export const getVerifyEmailAuthVerifyEmailPostUrl = () => {
    return `/auth/verify-email`
}

export const verifyEmailAuthVerifyEmailPost = async (
    verifyCode: VerifyCode,
    options?: RequestInit
): Promise<verifyEmailAuthVerifyEmailPostResponse> => {
    return customFetch<verifyEmailAuthVerifyEmailPostResponse>(
        getVerifyEmailAuthVerifyEmailPostUrl(),
        {
            ...options,
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
            },
            body: JSON.stringify(verifyCode),
        }
    )
}

/**
 * @summary Logout
 */
export type logoutAuthLogoutPostResponse200 = {
    data: unknown
    status: 200
}

export type logoutAuthLogoutPostResponseSuccess =
    logoutAuthLogoutPostResponse200 & {
        headers: Headers
    }
export type logoutAuthLogoutPostResponse = logoutAuthLogoutPostResponseSuccess

export const getLogoutAuthLogoutPostUrl = () => {
    return `/auth/logout`
}

export const logoutAuthLogoutPost = async (
    options?: RequestInit
): Promise<logoutAuthLogoutPostResponse> => {
    return customFetch<logoutAuthLogoutPostResponse>(
        getLogoutAuthLogoutPostUrl(),
        {
            ...options,
            method: 'POST',
        }
    )
}

/**
 * @summary Get Me
 */
export type getMeAuthMeGetResponse200 = {
    data: UserMe
    status: 200
}

export type getMeAuthMeGetResponseSuccess = getMeAuthMeGetResponse200 & {
    headers: Headers
}
export type getMeAuthMeGetResponse = getMeAuthMeGetResponseSuccess

export const getGetMeAuthMeGetUrl = () => {
    return `/auth/me`
}

export const getMeAuthMeGet = async (
    options?: RequestInit
): Promise<getMeAuthMeGetResponse> => {
    return customFetch<getMeAuthMeGetResponse>(getGetMeAuthMeGetUrl(), {
        ...options,
        method: 'GET',
    })
}

/**
 * Generate a WebSocket authentication token.
 * @summary Get Ws Token
 */
export type getWsTokenAuthWsTokenGetResponse200 = {
    data: WsTokenResponse
    status: 200
}

export type getWsTokenAuthWsTokenGetResponseSuccess =
    getWsTokenAuthWsTokenGetResponse200 & {
        headers: Headers
    }
export type getWsTokenAuthWsTokenGetResponse =
    getWsTokenAuthWsTokenGetResponseSuccess

export const getGetWsTokenAuthWsTokenGetUrl = () => {
    return `/auth/ws-token`
}

export const getWsTokenAuthWsTokenGet = async (
    options?: RequestInit
): Promise<getWsTokenAuthWsTokenGetResponse> => {
    return customFetch<getWsTokenAuthWsTokenGetResponse>(
        getGetWsTokenAuthWsTokenGetUrl(),
        {
            ...options,
            method: 'GET',
        }
    )
}

/**
 * @summary Change Username
 */
export type changeUsernameAuthChangeUsernamePostResponse202 = {
    data: unknown
    status: 202
}

export type changeUsernameAuthChangeUsernamePostResponse422 = {
    data: HTTPValidationError
    status: 422
}

export type changeUsernameAuthChangeUsernamePostResponseSuccess =
    changeUsernameAuthChangeUsernamePostResponse202 & {
        headers: Headers
    }
export type changeUsernameAuthChangeUsernamePostResponseError =
    changeUsernameAuthChangeUsernamePostResponse422 & {
        headers: Headers
    }

export type changeUsernameAuthChangeUsernamePostResponse =
    | changeUsernameAuthChangeUsernamePostResponseSuccess
    | changeUsernameAuthChangeUsernamePostResponseError

export const getChangeUsernameAuthChangeUsernamePostUrl = () => {
    return `/auth/change-username`
}

export const changeUsernameAuthChangeUsernamePost = async (
    updateUsername: UpdateUsername,
    options?: RequestInit
): Promise<changeUsernameAuthChangeUsernamePostResponse> => {
    return customFetch<changeUsernameAuthChangeUsernamePostResponse>(
        getChangeUsernameAuthChangeUsernamePostUrl(),
        {
            ...options,
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
            },
            body: JSON.stringify(updateUsername),
        }
    )
}

/**
 * @summary Change Email
 */
export type changeEmailAuthChangeEmailPostResponse202 = {
    data: unknown
    status: 202
}

export type changeEmailAuthChangeEmailPostResponse422 = {
    data: HTTPValidationError
    status: 422
}

export type changeEmailAuthChangeEmailPostResponseSuccess =
    changeEmailAuthChangeEmailPostResponse202 & {
        headers: Headers
    }
export type changeEmailAuthChangeEmailPostResponseError =
    changeEmailAuthChangeEmailPostResponse422 & {
        headers: Headers
    }

export type changeEmailAuthChangeEmailPostResponse =
    | changeEmailAuthChangeEmailPostResponseSuccess
    | changeEmailAuthChangeEmailPostResponseError

export const getChangeEmailAuthChangeEmailPostUrl = () => {
    return `/auth/change-email`
}

export const changeEmailAuthChangeEmailPost = async (
    updateEmail: UpdateEmail,
    options?: RequestInit
): Promise<changeEmailAuthChangeEmailPostResponse> => {
    return customFetch<changeEmailAuthChangeEmailPostResponse>(
        getChangeEmailAuthChangeEmailPostUrl(),
        {
            ...options,
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
            },
            body: JSON.stringify(updateEmail),
        }
    )
}

/**
 * @summary Change Password
 */
export type changePasswordAuthChangePasswordPostResponse202 = {
    data: unknown
    status: 202
}

export type changePasswordAuthChangePasswordPostResponse422 = {
    data: HTTPValidationError
    status: 422
}

export type changePasswordAuthChangePasswordPostResponseSuccess =
    changePasswordAuthChangePasswordPostResponse202 & {
        headers: Headers
    }
export type changePasswordAuthChangePasswordPostResponseError =
    changePasswordAuthChangePasswordPostResponse422 & {
        headers: Headers
    }

export type changePasswordAuthChangePasswordPostResponse =
    | changePasswordAuthChangePasswordPostResponseSuccess
    | changePasswordAuthChangePasswordPostResponseError

export const getChangePasswordAuthChangePasswordPostUrl = () => {
    return `/auth/change-password`
}

export const changePasswordAuthChangePasswordPost = async (
    updatePassword: UpdatePassword,
    options?: RequestInit
): Promise<changePasswordAuthChangePasswordPostResponse> => {
    return customFetch<changePasswordAuthChangePasswordPostResponse>(
        getChangePasswordAuthChangePasswordPostUrl(),
        {
            ...options,
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
            },
            body: JSON.stringify(updatePassword),
        }
    )
}

/**
 * @summary Verify Action
 */
export type verifyActionAuthVerifyActionPostResponse200 = {
    data: unknown
    status: 200
}

export type verifyActionAuthVerifyActionPostResponse422 = {
    data: HTTPValidationError
    status: 422
}

export type verifyActionAuthVerifyActionPostResponseSuccess =
    verifyActionAuthVerifyActionPostResponse200 & {
        headers: Headers
    }
export type verifyActionAuthVerifyActionPostResponseError =
    verifyActionAuthVerifyActionPostResponse422 & {
        headers: Headers
    }

export type verifyActionAuthVerifyActionPostResponse =
    | verifyActionAuthVerifyActionPostResponseSuccess
    | verifyActionAuthVerifyActionPostResponseError

export const getVerifyActionAuthVerifyActionPostUrl = () => {
    return `/auth/verify-action`
}

export const verifyActionAuthVerifyActionPost = async (
    verifyAction: VerifyAction,
    options?: RequestInit
): Promise<verifyActionAuthVerifyActionPostResponse> => {
    return customFetch<verifyActionAuthVerifyActionPostResponse>(
        getVerifyActionAuthVerifyActionPostUrl(),
        {
            ...options,
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
            },
            body: JSON.stringify(verifyAction),
        }
    )
}

/**
 * Accepts a new single order.
 * @summary Create Order
 */
export type createOrderOrdersPostResponse202 = {
    data: SingleOrderResponse
    status: 202
}

export type createOrderOrdersPostResponse422 = {
    data: HTTPValidationError
    status: 422
}

export type createOrderOrdersPostResponseSuccess =
    createOrderOrdersPostResponse202 & {
        headers: Headers
    }
export type createOrderOrdersPostResponseError =
    createOrderOrdersPostResponse422 & {
        headers: Headers
    }

export type createOrderOrdersPostResponse =
    | createOrderOrdersPostResponseSuccess
    | createOrderOrdersPostResponseError

export const getCreateOrderOrdersPostUrl = () => {
    return `/orders/`
}

export const createOrderOrdersPost = async (
    singleOrderCreate: SingleOrderCreate,
    options?: RequestInit
): Promise<createOrderOrdersPostResponse> => {
    return customFetch<createOrderOrdersPostResponse>(
        getCreateOrderOrdersPostUrl(),
        {
            ...options,
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
            },
            body: JSON.stringify(singleOrderCreate),
        }
    )
}

/**
 * Retrieves a paginated list of orders for the authenticated user,
with optional filtering.
 * @summary Get Orders
 */
export type getOrdersOrdersGetResponse200 = {
    data: PaginatedResponseOrderRead
    status: 200
}

export type getOrdersOrdersGetResponse422 = {
    data: HTTPValidationError
    status: 422
}

export type getOrdersOrdersGetResponseSuccess =
    getOrdersOrdersGetResponse200 & {
        headers: Headers
    }
export type getOrdersOrdersGetResponseError = getOrdersOrdersGetResponse422 & {
    headers: Headers
}

export type getOrdersOrdersGetResponse =
    | getOrdersOrdersGetResponseSuccess
    | getOrdersOrdersGetResponseError

export const getGetOrdersOrdersGetUrl = (params?: GetOrdersOrdersGetParams) => {
    const normalizedParams = new URLSearchParams()

    Object.entries(params || {}).forEach(([key, value]) => {
        if (value !== undefined) {
            if (Array.isArray(value)) {
                value.forEach((v) => normalizedParams.append(key, v))
            } else {
                normalizedParams.append(
                    key,
                    value === null ? 'null' : value.toString()
                )
            }
        }
    })

    const stringifiedParams = normalizedParams.toString()

    return stringifiedParams.length > 0
        ? `/orders/?${stringifiedParams}`
        : `/orders/`
}

export const getOrdersOrdersGet = async (
    params?: GetOrdersOrdersGetParams,
    options?: RequestInit
): Promise<getOrdersOrdersGetResponse> => {
    return customFetch<getOrdersOrdersGetResponse>(
        getGetOrdersOrdersGetUrl(params),
        {
            ...options,
            method: 'GET',
        }
    )
}

/**
 * Accepts a new OCO (One-Cancels-the-Other) order group.
 * @summary Create Oco Order
 */
export type createOcoOrderOrdersOcoPostResponse202 = {
    data: OCOOrderResponse
    status: 202
}

export type createOcoOrderOrdersOcoPostResponse422 = {
    data: HTTPValidationError
    status: 422
}

export type createOcoOrderOrdersOcoPostResponseSuccess =
    createOcoOrderOrdersOcoPostResponse202 & {
        headers: Headers
    }
export type createOcoOrderOrdersOcoPostResponseError =
    createOcoOrderOrdersOcoPostResponse422 & {
        headers: Headers
    }

export type createOcoOrderOrdersOcoPostResponse =
    | createOcoOrderOrdersOcoPostResponseSuccess
    | createOcoOrderOrdersOcoPostResponseError

export const getCreateOcoOrderOrdersOcoPostUrl = () => {
    return `/orders/oco`
}

export const createOcoOrderOrdersOcoPost = async (
    oCOOrderCreate: OCOOrderCreate,
    options?: RequestInit
): Promise<createOcoOrderOrdersOcoPostResponse> => {
    return customFetch<createOcoOrderOrdersOcoPostResponse>(
        getCreateOcoOrderOrdersOcoPostUrl(),
        {
            ...options,
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
            },
            body: JSON.stringify(oCOOrderCreate),
        }
    )
}

/**
 * Accepts a new OTO (One-Triggers-the-Other) order group.
 * @summary Create Oto Order
 */
export type createOtoOrderOrdersOtoPostResponse202 = {
    data: OTOOrderResponse
    status: 202
}

export type createOtoOrderOrdersOtoPostResponse422 = {
    data: HTTPValidationError
    status: 422
}

export type createOtoOrderOrdersOtoPostResponseSuccess =
    createOtoOrderOrdersOtoPostResponse202 & {
        headers: Headers
    }
export type createOtoOrderOrdersOtoPostResponseError =
    createOtoOrderOrdersOtoPostResponse422 & {
        headers: Headers
    }

export type createOtoOrderOrdersOtoPostResponse =
    | createOtoOrderOrdersOtoPostResponseSuccess
    | createOtoOrderOrdersOtoPostResponseError

export const getCreateOtoOrderOrdersOtoPostUrl = () => {
    return `/orders/oto`
}

export const createOtoOrderOrdersOtoPost = async (
    oTOOrderCreate: OTOOrderCreate,
    options?: RequestInit
): Promise<createOtoOrderOrdersOtoPostResponse> => {
    return customFetch<createOtoOrderOrdersOtoPostResponse>(
        getCreateOtoOrderOrdersOtoPostUrl(),
        {
            ...options,
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
            },
            body: JSON.stringify(oTOOrderCreate),
        }
    )
}

/**
 * Accepts a new OTOCO (One-Triggers-One-Cancels-the-Other) order group.
 * @summary Create Otoco Order
 */
export type createOtocoOrderOrdersOtocoPostResponse202 = {
    data: OTOCOOrderResponse
    status: 202
}

export type createOtocoOrderOrdersOtocoPostResponse422 = {
    data: HTTPValidationError
    status: 422
}

export type createOtocoOrderOrdersOtocoPostResponseSuccess =
    createOtocoOrderOrdersOtocoPostResponse202 & {
        headers: Headers
    }
export type createOtocoOrderOrdersOtocoPostResponseError =
    createOtocoOrderOrdersOtocoPostResponse422 & {
        headers: Headers
    }

export type createOtocoOrderOrdersOtocoPostResponse =
    | createOtocoOrderOrdersOtocoPostResponseSuccess
    | createOtocoOrderOrdersOtocoPostResponseError

export const getCreateOtocoOrderOrdersOtocoPostUrl = () => {
    return `/orders/otoco`
}

export const createOtocoOrderOrdersOtocoPost = async (
    oTOCOOrderCreate: OTOCOOrderCreate,
    options?: RequestInit
): Promise<createOtocoOrderOrdersOtocoPostResponse> => {
    return customFetch<createOtocoOrderOrdersOtocoPostResponse>(
        getCreateOtocoOrderOrdersOtocoPostUrl(),
        {
            ...options,
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
            },
            body: JSON.stringify(oTOCOOrderCreate),
        }
    )
}

/**
 * Retrieves a single order by its ID.
 * @summary Get Order
 */
export type getOrderOrdersOrderIdGetResponse200 = {
    data: OrderRead
    status: 200
}

export type getOrderOrdersOrderIdGetResponse422 = {
    data: HTTPValidationError
    status: 422
}

export type getOrderOrdersOrderIdGetResponseSuccess =
    getOrderOrdersOrderIdGetResponse200 & {
        headers: Headers
    }
export type getOrderOrdersOrderIdGetResponseError =
    getOrderOrdersOrderIdGetResponse422 & {
        headers: Headers
    }

export type getOrderOrdersOrderIdGetResponse =
    | getOrderOrdersOrderIdGetResponseSuccess
    | getOrderOrdersOrderIdGetResponseError

export const getGetOrderOrdersOrderIdGetUrl = (orderId: string) => {
    return `/orders/${orderId}`
}

export const getOrderOrdersOrderIdGet = async (
    orderId: string,
    options?: RequestInit
): Promise<getOrderOrdersOrderIdGetResponse> => {
    return customFetch<getOrderOrdersOrderIdGetResponse>(
        getGetOrderOrdersOrderIdGetUrl(orderId),
        {
            ...options,
            method: 'GET',
        }
    )
}

/**
 * Requests modification of an active order (e.g., changing the price).
 * @summary Modify an active order
 */
export type modifyOrderOrdersOrderIdPatchResponse202 = {
    data: unknown
    status: 202
}

export type modifyOrderOrdersOrderIdPatchResponse422 = {
    data: HTTPValidationError
    status: 422
}

export type modifyOrderOrdersOrderIdPatchResponseSuccess =
    modifyOrderOrdersOrderIdPatchResponse202 & {
        headers: Headers
    }
export type modifyOrderOrdersOrderIdPatchResponseError =
    modifyOrderOrdersOrderIdPatchResponse422 & {
        headers: Headers
    }

export type modifyOrderOrdersOrderIdPatchResponse =
    | modifyOrderOrdersOrderIdPatchResponseSuccess
    | modifyOrderOrdersOrderIdPatchResponseError

export const getModifyOrderOrdersOrderIdPatchUrl = (orderId: string) => {
    return `/orders/${orderId}`
}

export const modifyOrderOrdersOrderIdPatch = async (
    orderId: string,
    orderModify: OrderModify,
    options?: RequestInit
): Promise<modifyOrderOrdersOrderIdPatchResponse> => {
    return customFetch<modifyOrderOrdersOrderIdPatchResponse>(
        getModifyOrderOrdersOrderIdPatchUrl(orderId),
        {
            ...options,
            method: 'PATCH',
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
            },
            body: JSON.stringify(orderModify),
        }
    )
}

/**
 * Sends a request to cancel a specific order by its ID.
 * @summary Cancel a specific order
 */
export type cancelOrderOrdersOrderIdDeleteResponse202 = {
    data: unknown
    status: 202
}

export type cancelOrderOrdersOrderIdDeleteResponse422 = {
    data: HTTPValidationError
    status: 422
}

export type cancelOrderOrdersOrderIdDeleteResponseSuccess =
    cancelOrderOrdersOrderIdDeleteResponse202 & {
        headers: Headers
    }
export type cancelOrderOrdersOrderIdDeleteResponseError =
    cancelOrderOrdersOrderIdDeleteResponse422 & {
        headers: Headers
    }

export type cancelOrderOrdersOrderIdDeleteResponse =
    | cancelOrderOrdersOrderIdDeleteResponseSuccess
    | cancelOrderOrdersOrderIdDeleteResponseError

export const getCancelOrderOrdersOrderIdDeleteUrl = (orderId: string) => {
    return `/orders/${orderId}`
}

export const cancelOrderOrdersOrderIdDelete = async (
    orderId: string,
    options?: RequestInit
): Promise<cancelOrderOrdersOrderIdDeleteResponse> => {
    return customFetch<cancelOrderOrdersOrderIdDeleteResponse>(
        getCancelOrderOrdersOrderIdDeleteUrl(orderId),
        {
            ...options,
            method: 'DELETE',
        }
    )
}

/**
 * Retrieves all orders belonging to a specific order group
for the authenticated user.
 * @summary Get all orders in an order group
 */
export type getOrdersByGroupOrdersGroupsGroupIdGetResponse200 = {
    data: OrderRead[]
    status: 200
}

export type getOrdersByGroupOrdersGroupsGroupIdGetResponse422 = {
    data: HTTPValidationError
    status: 422
}

export type getOrdersByGroupOrdersGroupsGroupIdGetResponseSuccess =
    getOrdersByGroupOrdersGroupsGroupIdGetResponse200 & {
        headers: Headers
    }
export type getOrdersByGroupOrdersGroupsGroupIdGetResponseError =
    getOrdersByGroupOrdersGroupsGroupIdGetResponse422 & {
        headers: Headers
    }

export type getOrdersByGroupOrdersGroupsGroupIdGetResponse =
    | getOrdersByGroupOrdersGroupsGroupIdGetResponseSuccess
    | getOrdersByGroupOrdersGroupsGroupIdGetResponseError

export const getGetOrdersByGroupOrdersGroupsGroupIdGetUrl = (
    groupId: string
) => {
    return `/orders/groups/${groupId}`
}

export const getOrdersByGroupOrdersGroupsGroupIdGet = async (
    groupId: string,
    options?: RequestInit
): Promise<getOrdersByGroupOrdersGroupsGroupIdGetResponse> => {
    return customFetch<getOrdersByGroupOrdersGroupsGroupIdGetResponse>(
        getGetOrdersByGroupOrdersGroupsGroupIdGetUrl(groupId),
        {
            ...options,
            method: 'GET',
        }
    )
}

/**
 * @summary Healthcheck
 */
export type healthcheckPublicHealthcheckGetResponse200 = {
    data: unknown
    status: 200
}

export type healthcheckPublicHealthcheckGetResponseSuccess =
    healthcheckPublicHealthcheckGetResponse200 & {
        headers: Headers
    }
export type healthcheckPublicHealthcheckGetResponse =
    healthcheckPublicHealthcheckGetResponseSuccess

export const getHealthcheckPublicHealthcheckGetUrl = () => {
    return `/public/healthcheck`
}

export const healthcheckPublicHealthcheckGet = async (
    options?: RequestInit
): Promise<healthcheckPublicHealthcheckGetResponse> => {
    return customFetch<healthcheckPublicHealthcheckGetResponse>(
        getHealthcheckPublicHealthcheckGetUrl(),
        {
            ...options,
            method: 'GET',
        }
    )
}

/**
 * @summary Contact Us
 */
export type contactUsPublicContactPostResponse202 = {
    data: unknown
    status: 202
}

export type contactUsPublicContactPostResponse422 = {
    data: HTTPValidationError
    status: 422
}

export type contactUsPublicContactPostResponseSuccess =
    contactUsPublicContactPostResponse202 & {
        headers: Headers
    }
export type contactUsPublicContactPostResponseError =
    contactUsPublicContactPostResponse422 & {
        headers: Headers
    }

export type contactUsPublicContactPostResponse =
    | contactUsPublicContactPostResponseSuccess
    | contactUsPublicContactPostResponseError

export const getContactUsPublicContactPostUrl = () => {
    return `/public/contact`
}

export const contactUsPublicContactPost = async (
    contactForm: ContactForm,
    options?: RequestInit
): Promise<contactUsPublicContactPostResponse> => {
    return customFetch<contactUsPublicContactPostResponse>(
        getContactUsPublicContactPostUrl(),
        {
            ...options,
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                ...options?.headers,
            },
            body: JSON.stringify(contactForm),
        }
    )
}

/**
 * @summary Get User Overview
 */
export type getUserOverviewUserGetResponse200 = {
    data: unknown
    status: 200
}

export type getUserOverviewUserGetResponseSuccess =
    getUserOverviewUserGetResponse200 & {
        headers: Headers
    }
export type getUserOverviewUserGetResponse =
    getUserOverviewUserGetResponseSuccess

export const getGetUserOverviewUserGetUrl = () => {
    return `/user/`
}

export const getUserOverviewUserGet = async (
    options?: RequestInit
): Promise<getUserOverviewUserGetResponse> => {
    return customFetch<getUserOverviewUserGetResponse>(
        getGetUserOverviewUserGetUrl(),
        {
            ...options,
            method: 'GET',
        }
    )
}

/**
 * Retrieves user events (order or balance) with optional symbol filtering.
Returns events in descending order of timestamp.
 * @summary Get User Events
 */
export type getUserEventsUserEventsGetResponse200 = {
    data: PaginatedResponseOrderEventRead | PaginatedResponseBalanceEventRead
    status: 200
}

export type getUserEventsUserEventsGetResponse422 = {
    data: HTTPValidationError
    status: 422
}

export type getUserEventsUserEventsGetResponseSuccess =
    getUserEventsUserEventsGetResponse200 & {
        headers: Headers
    }
export type getUserEventsUserEventsGetResponseError =
    getUserEventsUserEventsGetResponse422 & {
        headers: Headers
    }

export type getUserEventsUserEventsGetResponse =
    | getUserEventsUserEventsGetResponseSuccess
    | getUserEventsUserEventsGetResponseError

export const getGetUserEventsUserEventsGetUrl = (
    params: GetUserEventsUserEventsGetParams
) => {
    const normalizedParams = new URLSearchParams()

    Object.entries(params || {}).forEach(([key, value]) => {
        if (value !== undefined) {
            normalizedParams.append(
                key,
                value === null ? 'null' : value.toString()
            )
        }
    })

    const stringifiedParams = normalizedParams.toString()

    return stringifiedParams.length > 0
        ? `/user/events?${stringifiedParams}`
        : `/user/events`
}

export const getUserEventsUserEventsGet = async (
    params: GetUserEventsUserEventsGetParams,
    options?: RequestInit
): Promise<getUserEventsUserEventsGetResponse> => {
    return customFetch<getUserEventsUserEventsGetResponse>(
        getGetUserEventsUserEventsGetUrl(params),
        {
            ...options,
            method: 'GET',
        }
    )
}

/**
 * Retrieves asset balances for the authenticated user.
Optionally filter by comma-separated list of symbols.

Example: /user/asset-balances?symbols=BTCUSD,ETHUSD
 * @summary Get Asset Balances
 */
export type getAssetBalancesUserAssetBalancesGetResponse200 = {
    data: AssetBalanceItem[]
    status: 200
}

export type getAssetBalancesUserAssetBalancesGetResponse422 = {
    data: HTTPValidationError
    status: 422
}

export type getAssetBalancesUserAssetBalancesGetResponseSuccess =
    getAssetBalancesUserAssetBalancesGetResponse200 & {
        headers: Headers
    }
export type getAssetBalancesUserAssetBalancesGetResponseError =
    getAssetBalancesUserAssetBalancesGetResponse422 & {
        headers: Headers
    }

export type getAssetBalancesUserAssetBalancesGetResponse =
    | getAssetBalancesUserAssetBalancesGetResponseSuccess
    | getAssetBalancesUserAssetBalancesGetResponseError

export const getGetAssetBalancesUserAssetBalancesGetUrl = (
    params?: GetAssetBalancesUserAssetBalancesGetParams
) => {
    const normalizedParams = new URLSearchParams()

    Object.entries(params || {}).forEach(([key, value]) => {
        if (value !== undefined) {
            normalizedParams.append(
                key,
                value === null ? 'null' : value.toString()
            )
        }
    })

    const stringifiedParams = normalizedParams.toString()

    return stringifiedParams.length > 0
        ? `/user/asset-balances?${stringifiedParams}`
        : `/user/asset-balances`
}

export const getAssetBalancesUserAssetBalancesGet = async (
    params?: GetAssetBalancesUserAssetBalancesGetParams,
    options?: RequestInit
): Promise<getAssetBalancesUserAssetBalancesGetResponse> => {
    return customFetch<getAssetBalancesUserAssetBalancesGetResponse>(
        getGetAssetBalancesUserAssetBalancesGetUrl(params),
        {
            ...options,
            method: 'GET',
        }
    )
}

/**
 * Retrieves OHLC bars for a given symbol and timeframe.
Supports pagination via next_page_token.
 * @summary Get Market Bars
 */
export type getMarketBarsMarketsSymbolBarsGetResponse200 = {
    data: BarsResponse
    status: 200
}

export type getMarketBarsMarketsSymbolBarsGetResponse422 = {
    data: HTTPValidationError
    status: 422
}

export type getMarketBarsMarketsSymbolBarsGetResponseSuccess =
    getMarketBarsMarketsSymbolBarsGetResponse200 & {
        headers: Headers
    }
export type getMarketBarsMarketsSymbolBarsGetResponseError =
    getMarketBarsMarketsSymbolBarsGetResponse422 & {
        headers: Headers
    }

export type getMarketBarsMarketsSymbolBarsGetResponse =
    | getMarketBarsMarketsSymbolBarsGetResponseSuccess
    | getMarketBarsMarketsSymbolBarsGetResponseError

export const getGetMarketBarsMarketsSymbolBarsGetUrl = (
    symbol: string,
    params: GetMarketBarsMarketsSymbolBarsGetParams
) => {
    const normalizedParams = new URLSearchParams()

    Object.entries(params || {}).forEach(([key, value]) => {
        if (value !== undefined) {
            normalizedParams.append(
                key,
                value === null ? 'null' : value.toString()
            )
        }
    })

    const stringifiedParams = normalizedParams.toString()

    return stringifiedParams.length > 0
        ? `/markets/${symbol}/bars?${stringifiedParams}`
        : `/markets/${symbol}/bars`
}

export const getMarketBarsMarketsSymbolBarsGet = async (
    symbol: string,
    params: GetMarketBarsMarketsSymbolBarsGetParams,
    options?: RequestInit
): Promise<getMarketBarsMarketsSymbolBarsGetResponse> => {
    return customFetch<getMarketBarsMarketsSymbolBarsGetResponse>(
        getGetMarketBarsMarketsSymbolBarsGetUrl(symbol, params),
        {
            ...options,
            method: 'GET',
        }
    )
}
